---
title: 'Modifying OpenThread to Support ASCON'
description: "How I modified OpenThread to support ASCON-128a and ASCON-128 encryption algorithms."
date: 09-13-2026
draft: false
---

import Callout from "@/components/Callout.astro";

---

## Introduction

For my [Master's Thesis](https://simeonat.github.io/research/thesis/), I modified [OpenThread](https://openthread.io/), Google's open source implementation of the [Thread](https://www.threadgroup.org/) commercial IoT protocol, to support the symmetric encryption algorithms defined in the [NIST endorsed](https://csrc.nist.gov/news/2023/lightweight-cryptography-nist-selects-ascon) [ASCON](https://ascon.isec.tugraz.at/) cipher suite. 

My thesis mainly focused on the ***science***, showing that when the cipher built into OpenThread: AES-CCM, is replaced with ASCON AEAD, there is *no significant adverse impact* in the network performance and energy consumption of Thread devices. 

In this post, I'm going to focus on the ***engineering*** part of my thesis: how did I modify OpenThread to support ASCON-128a and ASCON-128 -- for [ESP32 Thread devices](https://openthread.io/vendors/espressif) in particular. I will discuss the changes I made, along with the challenges I encountered and how I went about solving them.

<Callout type="info">
  NIST has [standarized the ASCON cipher suite](https://www.nist.gov/news-events/news/2025/08/nist-finalizes-lightweight-cryptography-standard-protect-small-devices) in August 2025. However, I completed my Master's Thesis before NIST's standardization of ASCON. Instead, I used a third-party implementation of ASCON: [LibAscon](https://github.com/TheMatjaz/LibAscon), in my thesis. LibAscon contains implementations for ASCON-128a and ASCON-128, which were defined in [version 1.2 of the ASCON specification](https://link.springer.com/article/10.1007/s00145-021-09398-9). Repeating my thesis research on the official [implementation](https://github.com/ascon/ascon-c) of [Ascon-AEAD128](https://csrc.nist.gov/pubs/sp/800/232/final), NIST's standardized ASCON AEAD algorithm, is left for future work.
</Callout>

## Overview

For my thesis, I had to modify OpenThread so it is capable of using the ASCON AEAD algorithms on 802.15.4 compatible[^1]  ESP32 devices. 

However, I couldn't just fork and edit the [official OpenThread GitHub repository](https://github.com/openthread/openthread), since the codebase is designed to be hardware-agnostic. As a result, modifications had to be made in the source code of [ESP-IDF](https://github.com/espressif/esp-idf), the open source development framework that is managed by Espressif, the hardware manufacturer of ESP32s. ESP-IDF includes [Espressif's fork of OpenThread](https://github.com/espressif/openthread) as a Git submodule, and provides this fork as a dependency that can be imported into an ESP-IDF project whenever developers wish to run OpenThread on their ESP32 devices. 

Thus, I had to fork both the ESP-IDF codebase and Espressif's OpenThread fork (rather than the official OpenThread repository). My forks of [ESP-IDF](https://github.com/UCSC-ThreadAscon/esp-idf) and [Espressif's fork of OpenThread](https://github.com/UCSC-ThreadAscon/openthread) are publicly available on GitHub. Commits are always being made to ESP-IDF source code and the Espressif OpenThread fork on an often basis. I always update my forks to be up-to-date with the `main` or `master` branches of their respective upstream repositories whenever new changes are made.

The forks of ESP-IDF and the Espressif OpenThread fork collectively make up my modified version of OpenThread that can run ASCON-128a and ASCON-128 on 802.15.4 compatible ESP32 microcontrollers. In addition, my modified OpenThread implementation enables users to specify  whether ASCON-128a or ASCON-128 should be used for encryption with the use of a compiler flag.

Furthermore, the forks do not support the ability to use ASCON-80pq, as the creators of ASCON [encourage the use of ASCON-128 and ASCON-128a over ASCON-80pq](https://link.springer.com/article/10.1007/s00145-021-09398-9#Sec2). As a matter of fact, a [recommendation](https://csrc.nist.gov/csrc/media/Events/2023/lightweight-cryptography-workshop-2023/documents/accepted-papers/03-proposals-for-standardization-of-ascon-family.pdf) has additionally been made to remove ASCON-80pq from the official, standardized version of the ASCON cipher suite that will be developed by NIST. 

### The nRF Packet Sniffer

<figure>
  {/* The CSS code that uses flexbox to put the two images next to each other came from
      the Google Search AI. The Google Search AI's code can be found here:
      https://docs.google.com/document/d/1wKH8ecG8voev7amT-NLnjz7Y-nV5fqgvidCVWl6z_Po/edit?usp=sharing
  */}
  <div style="display: flex; justify-content: space-around;">
    <img src="/images/thesis-blog-post/nrf-dongle.png" width="250"/> 
    <img src="/images/thesis-blog-post/nrf52840-devkit.png" width="300"/> 
  </div>
  <figcaption>
    Pictures of the [nRF52840 dongle](https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/nRF52840-Dongle-product-brief.pdf) (left) and the [nRF52840 development kit](https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/nRF52840-DK-product-brief.pdf) (right) from their respective broduct briefs.
  </figcaption>
</figure>

A really useful tool that I used in the process of replacing AES-CCM with ASCON AEAD was the [nRF 802.15.4 packet sniffer software](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-802154) created by Nordic Semiconductors. The 802.15.4 packet sniffer is designed to be run on either the [nRF52840 development kit](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-802154) or the [nRF52840 dongle](https://www.nordicsemi.com/Products/Development-hardware/nRF52840-Dongle).

The nRF52840 dongle was set up to run the nRF 802.15.4 packet sniffer such that it is able to listen to and display the packets sent between my ESP32 devices on [Wireshark](https://www.nordicsemi.com/Products/Development-hardware/nRF52840-Dongle). Since Thread is encrypted under AES-CCM, I had to give Wireshark the Thread network key used by my ESP32 devices in order for it to be able to properly decrypt and parse the contents of in-flight packets.

<figure>
  <img src="/images/thesis-blog-post/wireshark-mle.png" />
  <figcaption>
    A screenshot of Wireshark displaying the AES-CCM encrypted packets captured by my nRF52840 dongle.
  </figcaption>
</figure>

## Removing AES-CCM

Before ASCON-128a and ASCON-128 could be integrated into OpenThread, AES-CCM needed to be removed. Once the ESP32 802.15.4 compatible devices were able to communicate successfully over plaintext, it was then possible to add ASCON AEAD on top of these plaintext communications. AES-CCM is used in the Thread protocol during:

* The encryption and decryption of data packets (which carry application layer data) at the MAC layer.

* The encryption and decryption of packets sent under the Mesh Link Establishment (MLE) protocol, which occurs over UDP at the transport layer.

Thus, in this section, I will describe how I removed the use of AES-CCM in OpenThread in these particular aspects of the protocol. However, I must note that AES-CCM was not removed in its entirety within the forks; the [headers](https://github.com/UCSC-ThreadAscon/openthread/blob/main/src/core/crypto/aes_ccm.hpp) and [source](https://github.com/UCSC-ThreadAscon/openthread/blob/main/src/core/crypto/aes_ccm.cpp) files which define the AES-CCM API in OpenThread still remain. 

Instead, I removed the specific function calls which invoke AES-CCM were removed, there definitions of functions which implement AES-CCM were modified so that no encryption or decryption would be done.

### Removing AES-CCM MAC Layer Encryption

Based on the source code in both ESP-IDF and Espressif's OpenThread fork, the process of encryption happens immediately before a MAC frame is transmitted. Given the Thread network key and a nonce, AES-CCM is used to create a ciphertext that is of the exact same length as the plaintext, along with a $32$ bit Message Integrity Counter (MIC) that is appended at the end of the frame.

The [Thread specification](https://www.threadgroup.org/ThreadSpec) states that the nonce to be used in all MAC frames must follow the format described in the 802.15.4-2006 specification. The [802.15.4-2006 specification](https://standards.ieee.org/ieee/802.15.4/3582/) specifies that an AES-CCM nonce is composed of the 802.15.4 Extended Address of the sender, the frame counter, and the security level of the frame. All three attributes can be found in the header of the MAC frame.

<figure>
  <img src="/images/thesis-blog-post/aesccm-nonce.png" width="500" />
  <figcaption>
    The format of a nonce as input to AES-CCM encryption, as described in [802.15.4-2006](https://standards.ieee.org/ieee/802.15.4/3582/).
  </figcaption>
</figure>

Both software and hardware encryption are used by ESP32 devices when doing AES-CCM MAC layer encryption in OpenThread. AES-CCM encryption is done in *software* when encrypting MAC frames that are sent during commissioning. On the other hand, *hardware* encryption is used instead to
protect MAC frames that are transmitted once a device is part of a Thread network. In other words, hardware encryption is used on all MAC frames sent which carry application layer[^2].

The implementation of AES-CCM software encryption is contained in the method `TxFrame::ProcessTransmitAesCcm()`, whose definition can be found in the `src/mac/mac_frame.cpp` source file of the Espressif OpenThread fork. The `Mac::ProcessTransmitSecurity()` method in `src/mac/mac.cpp` invokes `ProcessTransmitAesCcm()` to do software encryption for MAC frames transmitted during commissioning. On the other hand, the hardware encryption used on frames carrying application layer data is invoked using the ESP32 802.15.4 API function `esp_ieee802154_set_transmit_security()`
called by `otPlatRadioTransmit()`, which in turn is defined in the OpenThread component directory of the ESP-IDF repository[^3].

---
[^1]: Thread, and hence, OpenThread, [operates on top of IEEE 802.15.4 MAC and physical layer standard](https://threadgroup.org/Newsroom/PID/1804/FilterMenu/1815/FilterCategories/19). Thus, all [ESP32 devices with an 802.15.4 transceiver](https://openthread.io/vendors/espressif) are capable of running OpenThread. 

[^2]: This includes fragments of MLE packets which cannot fit in a single frame, as the Thread specification requires them to be encrypted using MAC layer encryption.

[^3]: The function is specifically defined in `esp_openthread_radio.c` file, located in the
`components/openthread/src/port` directory of ESP-IDF.