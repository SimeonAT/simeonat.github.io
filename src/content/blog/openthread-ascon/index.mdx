---
title: 'Modifying OpenThread to Support ASCON Encryption'
description: "How I modified OpenThread to support ASCON-128a and ASCON-128 encryption algorithms."
date: 09-13-2026
draft: false
---

import Callout from "@/components/Callout.astro";

---

## Introduction

For my [Master's Thesis](https://simeonat.github.io/research/thesis/), I modified [OpenThread](https://openthread.io/), Google's open source implementation of the [Thread](https://www.threadgroup.org/) commercial IoT protocol, to support the symmetric encryption algorithms defined in the [NIST endorsed](https://csrc.nist.gov/news/2023/lightweight-cryptography-nist-selects-ascon) [ASCON](https://ascon.isec.tugraz.at/) cipher suite. 

My thesis mainly focused on the ***science***, showing that when the cipher built into OpenThread: AES-CCM, is replaced with ASCON AEAD, there is *no significant adverse impact* in the network performance and energy consumption of Thread devices. 

In this post, I'm going to focus on the ***engineering*** part of my thesis: how did I modify OpenThread to support ASCON-128a and ASCON-128 -- for [ESP32 Thread devices](https://openthread.io/vendors/espressif) in particular. I will discuss the changes I made, along with the challenges I encountered and how I went about solving them.

<Callout type="info">
  NIST has [standarized the ASCON cipher suite](https://www.nist.gov/news-events/news/2025/08/nist-finalizes-lightweight-cryptography-standard-protect-small-devices) in August 2025. However, I completed my Master's Thesis before NIST's standardization of ASCON. Instead, I used a third-party implementation of ASCON: [LibAscon](https://github.com/TheMatjaz/LibAscon), in my thesis. LibAscon contains implementations for ASCON-128a and ASCON-128, which were defined in [version 1.2 of the ASCON specification](https://link.springer.com/article/10.1007/s00145-021-09398-9). Repeating my thesis research on the official [implementation](https://github.com/ascon/ascon-c) of [Ascon-AEAD128](https://csrc.nist.gov/pubs/sp/800/232/final), NIST's standardized ASCON AEAD algorithm, is left for future work.
</Callout>

## Overview

For my thesis, I had to modify OpenThread so it is capable of using the ASCON AEAD algorithms on 802.15.4 compatible[^1]  ESP32 devices. 

However, I couldn't just fork and edit the [official OpenThread GitHub repository](https://github.com/openthread/openthread), since the codebase is designed to be hardware-agnostic. As a result, modifications had to be made in the source code of [ESP-IDF](https://github.com/espressif/esp-idf), the open source development framework that is managed by Espressif, the hardware manufacturer of ESP32s. ESP-IDF includes [Espressif's fork of OpenThread](https://github.com/espressif/openthread) as a Git submodule, and provides this fork as a dependency that can be imported into an ESP-IDF project whenever developers wish to run OpenThread on their ESP32 devices. 

Thus, I had to fork both the ESP-IDF codebase and Espressif's OpenThread fork (rather than the official OpenThread repository). My forks of [ESP-IDF](https://github.com/UCSC-ThreadAscon/esp-idf) and [Espressif's fork of OpenThread](https://github.com/UCSC-ThreadAscon/openthread) are publicly available on GitHub. Commits are always being made to ESP-IDF source code and the Espressif OpenThread fork on an often basis. I always update my forks to be up-to-date with the `main` or `master` branches of their respective upstream repositories whenever new changes are made.

The forks of ESP-IDF and the Espressif OpenThread fork collectively make up my modified version of OpenThread that can run ASCON-128a and ASCON-128 on 802.15.4 compatible ESP32 microcontrollers. In addition, my modified OpenThread implementation enables users to specify  whether ASCON-128a or ASCON-128 should be used for encryption with the use of a compiler flag.

Furthermore, the forks do not support the ability to use ASCON-80pq, as the creators of ASCON [encourage the use of ASCON-128 and ASCON-128a over ASCON-80pq](https://link.springer.com/article/10.1007/s00145-021-09398-9#Sec2). As a matter of fact, a [recommendation](https://csrc.nist.gov/csrc/media/Events/2023/lightweight-cryptography-workshop-2023/documents/accepted-papers/03-proposals-for-standardization-of-ascon-family.pdf) has additionally been made to remove ASCON-80pq from the official, standardized version of the ASCON cipher suite that will be developed by NIST. 

### The nRF Packet Sniffer

<figure>
  {/* The CSS code that uses flexbox to put the two images next to each other came from
      the Google Search AI. The Google Search AI's code can be found here:
      https://docs.google.com/document/d/1wKH8ecG8voev7amT-NLnjz7Y-nV5fqgvidCVWl6z_Po/edit?usp=sharing
  */}
  <div style="display: flex; justify-content: space-around;">
    <img src="/images/thesis-blog-post/nrf-dongle.png" width="250"/> 
    <img src="/images/thesis-blog-post/nrf52840-devkit.png" width="300"/> 
  </div>
  <figcaption>
    Pictures of the [nRF52840 dongle](https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/nRF52840-Dongle-product-brief.pdf) (left) and the [nRF52840 development kit](https://www.nordicsemi.com/-/media/Software-and-other-downloads/Product-Briefs/nRF52840-DK-product-brief.pdf) (right) from their respective broduct briefs.
  </figcaption>
</figure>

A really useful tool that I used in the process of replacing AES-CCM with ASCON AEAD was the [nRF 802.15.4 packet sniffer software](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-802154) created by Nordic Semiconductors. The 802.15.4 packet sniffer is designed to be run on either the [nRF52840 development kit](https://www.nordicsemi.com/Products/Development-tools/nRF-Sniffer-for-802154) or the [nRF52840 dongle](https://www.nordicsemi.com/Products/Development-hardware/nRF52840-Dongle).

The nRF52840 dongle was set up to run the nRF 802.15.4 packet sniffer such that it is able to listen to and display the packets sent between my ESP32 devices on [Wireshark](https://www.nordicsemi.com/Products/Development-hardware/nRF52840-Dongle). Since Thread is encrypted under AES-CCM, I had to give Wireshark the Thread network key used by my ESP32 devices in order for it to be able to properly decrypt and parse the contents of in-flight packets.

<figure>
  <img src="/images/thesis-blog-post/wireshark-mle.png" />
  <figcaption>
    A screenshot of Wireshark displaying the AES-CCM encrypted packets captured by my nRF52840 dongle.
  </figcaption>
</figure>

## Removing AES-CCM

Before ASCON-128a and ASCON-128 could be integrated into OpenThread, AES-CCM needed to be removed. Once the ESP32 802.15.4 compatible devices were able to communicate successfully over plaintext, it was then possible to add ASCON AEAD on top of these plaintext communications. AES-CCM is used in the Thread protocol during:

* The encryption and decryption of data packets (which carry application layer data) at the MAC layer.

* The encryption and decryption of packets sent under the Mesh Link Establishment (MLE) protocol, which occurs over UDP at the transport layer.

Thus, in this section, I will describe how I removed the use of AES-CCM in OpenThread in these particular aspects of the protocol. However, I must note that AES-CCM was not removed in its entirety within the forks; the [headers](https://github.com/UCSC-ThreadAscon/openthread/blob/main/src/core/crypto/aes_ccm.hpp) and [source](https://github.com/UCSC-ThreadAscon/openthread/blob/main/src/core/crypto/aes_ccm.cpp) files which define the AES-CCM API in OpenThread still remain. 

Instead, I removed the specific function calls which invoked AES-CCM. They were modified such that that no encryption or decryption would be done.

### AES MAC Layer Encryption

Based on the source code in both ESP-IDF and Espressif's OpenThread fork, the process of encryption happens immediately before a MAC frame is transmitted. Given the Thread network key and a nonce, AES-CCM is used to create a ciphertext that is of the exact same length as the plaintext, along with a 32 bit Message Integrity Counter (MIC) that is appended at the end of the frame.

The [Thread specification](https://www.threadgroup.org/ThreadSpec) states that the nonce to be used in all MAC frames must follow the format described in the 802.15.4-2006 specification. The [802.15.4-2006 specification](https://standards.ieee.org/ieee/802.15.4/3582/) specifies that an AES-CCM nonce is composed of the 802.15.4 Extended Address of the sender, the frame counter, and the security level of the frame. All three attributes can be found in the header of the MAC frame.

<figure>
  <img src="/images/thesis-blog-post/aesccm-nonce.png" width="500" />
  <figcaption>
    The format of a nonce as input to AES-CCM encryption, as described in [802.15.4-2006](https://standards.ieee.org/ieee/802.15.4/3582/).
  </figcaption>
</figure>

Both software and hardware encryption are used by ESP32 devices when doing AES-CCM MAC layer encryption in OpenThread. AES-CCM encryption is done in *software* when encrypting MAC frames that are sent during [commissioning](https://www.threadgroup.org/Portals/0/documents/support/CommissioningWhitePaper_658_2.pdf). On the other hand, *hardware* encryption is used instead to
protect MAC frames that are transmitted once a device is part of a Thread network. In other words, hardware encryption is used on all MAC frames sent which carry application layer[^2].

The implementation of AES-CCM software encryption is contained in the method `TxFrame::ProcessTransmitAesCcm()`, whose definition can be found in the `src/mac/mac_frame.cpp` source file of the Espressif OpenThread fork. The `Mac::ProcessTransmitSecurity()` method in `src/mac/mac.cpp` invokes `ProcessTransmitAesCcm()` to do software encryption for MAC frames transmitted during commissioning. On the other hand, the hardware encryption used on frames carrying application layer data is invoked using the [ESP32 802.15.4 API](https://github.com/espressif/esp-idf/tree/master/components/ieee802154) function `esp_ieee802154_set_transmit_security()`
called by `otPlatRadioTransmit()`, which in turn is defined in the OpenThread component directory of the ESP-IDF repository[^3].

Given that official OpenThread source code is hardware agonistic, its implementation does AES-CCM software encryption for *all* MAC frames -- even the frames which carry application layer data.
The source code for invoking AES-CCM software encryption for these type of frames is additionally present in the Espressif OpenThread fork; such code is defined in method `SubMac::ProcessTransmitSecurity()`, located in `src/mac/sub_mac.cpp` source file in the Espressif OpenThread fork.

The `SubMac` class implementation of `ProcessTransmitSecurity()` uses `TxFrame::ProcessTransmitAesCcm()` to do AES-CCM software  encryption on MAC frames responsible for carrying application layer data.
However, this method never runs in the Espressif OpenThread fork. At the beginning of `ProcessTransmitSecurity()`, the following line is used to determine whether AES-CCM software encryption should be used:
```cpp
VerifyOrExit(ShouldHandleTransmitSecurity());
```

If the inner function `ShouldHandleTransmitSecurity()` returns `false`, `ProcessTransmitSecurity()` will immediately return. On the other hand, when `true` is returned, `ProcessTransmitSecurity()` will continue on, using `ProcessTransmitAesCcm()` to encrypt the payload contained in the MAC frame that is to be transmitted. In the case of the Espressif OpenThread fork, `ShouldHandleTransmitSecurity()` always returns `false`. Hence, the task of encrypting MAC frames which carry application layer data is always passed along to the hardware. 

Additionally, the implementation of `ProcessTransmitSecurity()`  defined in the `Mac` class is responsible for encrypting MAC frames that are involved in the process of commissioning. The `Mac` implementation of `ProcessTransmitSecurity()` does not contain the `ShouldHandleTransmitSecurity()` function call.  As a result, and as shown in the figure below, software encryption (and *not* hardware encryption) will always be used on MAC frames that are transmitted during commissioning.

<figure>
  <img src="/images/thesis-blog-post/hardware-encrypt-print-statement.png" />
  <figcaption>
  I added a temporary print statement immediately before hardware encryption is invoked. The fact that these print statements are displayed right after I entered the OpenThread CLI command to send a UDP packet on a [Full Thread Device (FTD)](https://openthread.io/guides/thread-primer/node-roles-and-types) indicates that hardware encryption is used on MAC frames that application layer data.
  </figcaption>
</figure>

<figure>
  <img src="/images/thesis-blog-post/software-encryption-commissioner.png" />
  <figcaption>
  I added a temporary print statement immediately before the call to `ProcessTransmitAesCcm()` in the version of `Mac::ProcessTransmitSecurity()` that defined in the `Mac` class. Such print statements are displayed a FTD acting as a commissioner -- hence showing that *software encryption* occurs during commissioning.
  </figcaption>
</figure>

### AES MAC Layer Decryption

The AES decryption process involves using the Thread network key and nonce to both decrypt the ciphertext and ensure the validity of the ciphertext against the MIC. Similar to MAC layer encryption, the nonce is made up of data from the frame header -- particularly, the 802.15.4 Extended Address, the frame counter, and security level of the MAC frame. The nonce is assembled to follow the nonce format specified in 802.15.4-2006.

The ciphertext is decrypted first. After doing so, the decryption algorithm will attempt to recreate the MIC corresponding to the ciphertext and compare it to the MIC given in the packet. If both MICs match, the plaintext is sent for further processing. Otherwise, the frame gets dropped.

Unlike AES MAC layer encryption, AES MAC decryption is only done in *software*. A single method: `Frame::ProcessReceiveAesCcm()`, is used to decrypt MAC frames. Any caller that wishes to do AES-CCM decryption at the MAC layer must use this method.

### Removing AES-CCM MAC Layer Encryption & Decryption

I took a two-step approach in order to remove the use of AES at the MAC layer. First, I removed the functionality for doing MAC encryption. To confirm that I have successfully removed encryption, I made sure that I could see the application layer payloads of packets sent by my ESP32s in plaintext in Wireshark. Only after that I have confirmed that I have successfully removed encryption, I began working on removing the functionality for decryption. When I have successfully removed the use of both AES encryption and decryption at the MAC layer, I was able to see the application layer payloads in plaintext, and the devices were able to receive such data without any issues.


#### Removing MAC Layer *Encryption*

To remove AES encryption on frames carrying application layer data, the line which invoked the hardware to do the encryption needed to be removed. This line was the function call:
```cpp
esp_ieee802154_set_transmit_security(&aFrame->mPsdu[-1],
                                      s_security_key,
                                      s_security_addr);
```

which is used in `esp_openthread_radio.c`, a file that is a part of the ESP-IDF source code. This function passed to the ESP-IDF 802.15.4 API the necessary information needed by the hardware to follow the AES encryption procedure outlined in 802.15.4-2006.

After removing the line which invokes hardware encryption, I was able to see all data packets were carrying plaintext payloads, as shown in the figure below. Since the Thread protocol is designed
to use AES, Wireshark by default will attempt to decrypt all packets using AES before displaying them (shown in the figure below) --- including the packets that are sent in plaintext.
This is why Wireshark will display the "decrypted" payload of plaintext packets
as a bunch of random characters.

However, the removal of this line did not remove AES encryption for frames that are transmitted during commissioning, as these frames are encrypted in software. As a result, I had to modify the software AES MAC layer encryption function: `ProcessTransmitAesCcm()`, to prevent software encryption from occurring before transmitting frames sent during commissioning. In order to accomplish this, I modified the function so that it returns before it can even begin to run the lines responsible for encrypting 802.15.4 frames.

<figure>
  <img src="/images/thesis-blog-post/hello_world_aes.png" width="550" /> 
  <img src="/images/thesis-blog-post/hello_world_aes_parsed.png" width="550" /> 
  <figcaption>
    The top figures shows a UDP packet that my ESP32 device sent with the payload: `hello_world`, as ciphertext encrypted under AES-CCM. The bottom figure shows payload after Wireshark has decrypted it. 
  </figcaption>
</figure>

<figure>
  <img src="/images/thesis-blog-post/hello-ucsc-plaintext-packet.png" width="800" /> 
  <figcaption>
    A UDP packet with the payload `hello_ucsc_plaintext_packet` in plaintext. Note that Wireshark (unsuccessfully) decrypts this payload using AES, since all frames carrying application layer data will be encrypted in Thread.
  </figcaption>
</figure>

#### Removing MAC Layer *Decryption*

Unlike AES MAC encryption, which is done both in software and hardware, MAC layer decryption is instead done only in software. More specifically, the MAC layer software decryption is implemented in the `ProcessReceiveAesCcm()`, defined in the `mac_frame.cpp` source file, which is a part of the Espressif OpenThread fork. After doing so, my ESP32 Thread devices were able to successfully send and receive plaintext application layer data. However, the MLE packets were still encrypted
with AES.

### Removing MLE Encryption & Decryption

---
[^1]: Thread, and hence, OpenThread, [operates on top of IEEE 802.15.4 MAC and physical layer standard](https://threadgroup.org/Newsroom/PID/1804/FilterMenu/1815/FilterCategories/19). Thus, all [ESP32 devices with an 802.15.4 transceiver](https://openthread.io/vendors/espressif) are capable of running OpenThread. 

[^2]: This includes fragments of MLE packets which cannot fit in a single frame, as the Thread specification requires them to be encrypted using MAC layer encryption.

[^3]: The function is specifically defined in `esp_openthread_radio.c` file, located in the
`components/openthread/src/port` directory of ESP-IDF.